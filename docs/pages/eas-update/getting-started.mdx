---
title: Getting started
description: Learn how to get started with EAS Update and use in your project.
---

import ImageSpotlight from '~/components/plugins/ImageSpotlight';
import { Terminal } from '~/ui/components/Snippet';
import { Step } from '~/ui/components/Step';

Setting up EAS Update allows you to push critical bug fixes and improvements that your users need right away.

In this introduction, we create a new Expo app, run it in our local development environment, publish an update, and show that the app downloads and runs the update when restarted.

## Prerequisites

EAS Update requires the following versions or greater:

- EAS CLI >= 0.50.0
- Expo SDK >= 45.0.0
- expo-updates >= 0.13.0

The example app shown here is based on SDK 48, which supports the new `requestHeaders` property in **app.json**.

<Step label="1">
## Install the latest EAS CLI

EAS CLI is the command-line app that you will use to interact with EAS services from your terminal. To install it, run the command:

<Terminal cmd={['$ npm install --global eas-cli']} />

You can also use the above command to check if a new version of EAS CLI is available. We encourage you to always stay up to date with the latest version.

> We recommend using `npm` instead of `yarn` for global package installations. You may alternatively use `npx eas-cli`, just remember to use that instead of `eas` whenever it's called for in the documentation.

</Step>

<Step label="2">
## Create a project

Create a project by running:

<Terminal cmd={['$ npx create-expo-app']} />
</Step>

<Step label="3">
## Configure your project

To configure your project, run the following commands in the order they are specified:

<Terminal
  cmd={[
    '# Install the latest `expo-updates` library',
    '$ npx expo install expo-updates',
    '',
    '# Initialize the app in EAS',
    '$ eas init',
    '',
    '# Initialize your project with EAS Update',
    '$ eas update:configure',
    '',
  ]}
  cmdCopy="npx expo install expo-updates && eas init && eas update:configure"
/>

Inside **app.json**, make changes to use a fixed `runtimeVersion` property, and to add a request header that the app will use to specify a channel when downloading updates from EAS.

{/* prettier-ignore */}
```json app.json
  "expo": {
    /* @hide ... your existing configuration */ /* @end */
    "updates": {
      /* @hide ... */ /* @end */
      "requestHeaders": {
        "expo-channel-name": "main"
      }
      /* @hide ... */ /* @end */
    }
    /* @hide ... */ /* @end */
    runtimeVersion: '1.0.0',
    /* @hide ... */ /* @end */
  }
```

The `channel` allows you to point updates at builds. For example, if we set up a GitHub Action to publish changes on merge, it will make it so that we can merge code into the "production" Git branch. Then, each commit will trigger a GitHub Action that will publish an update that will be available to builds with the channel "production".

</Step>

<Step label="4">
## Run prebuild

This is run automatically when executing `npx expo run:ios` or `npx expo run:android`; however, we call this step out separately in this guide. In SDK 48 and later, this step adds our desired request headers to **Expo.plist** and **AndroidManifest.xml** in the iOS and Android builds, respectively.

<Terminal
  cmd={[
    '# Run prebuild to install and configure the ios and android directories, and install Cocoapods for iOS.',
    '$ npx expo prebuild',
    '',
  ]}
  cmdCopy="npx expo prebuild"
/>

After running the above, inspect **iOS/&lt;your project name&gt;/Supporting/Expo.plist** and **android/app/src/main/AndroidManifest.xml** to see the changes that were added.

{/* prettier-ignore */}
```xml Expo.plist
<!-- @hide ... your existing configuration --> <!-- @end -->
    <!-- @info New --> <key>EXUpdatesRequestHeaders</key> <!-- @end -->
    <!-- @info New --> <dict> <!-- @end -->
      <!-- @info New --> <key>expo-channel-name</key> <!-- @end -->
      <!-- @info New --> <string>main</string> <!-- @end -->
    <!-- @info New --> </dict> <!-- @end -->
<!-- @hide ... your existing configuration --><!-- @end -->
```

{/* prettier-ignore */}
```xml AndroidManifest.xml
<!-- @hide ... your existing configuration --> <!-- @end -->
    <!-- @info New --> <meta-data android:name="expo.modules.updates.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY" android:value="{&quot;expo-channel-name&quot;:&quot;main&quot;}"/> <!-- @end -->
<!-- @hide ... your existing configuration --><!-- @end -->
```

> If you do not see the above lines added to these files, it means that you are using SDK 47 or earlier, and you should add these lines manually.

</Step>

<Step label="5">
## Build the project

Run the following commands in order to get the app running on iOS or Android.

<Terminal
  cmd={[
    '# iOS: Build and run the app on a local iOS Simulator.',
    '$ npx expo run:ios --configuration Release',
    '',
    '# Android: Build and run the app on a local Android Emulator',
    '$ npx expo run:android --variant release',
    '',
  ]}
  cmdCopy="npx expo run:ios --configuration Release && npx expo run:android --variant release"
/>

(We build the release version of the app, not the debug version. By default, a debug build expects to connect to a local React Native packager to load the application bundle, and so will not connect to the EAS update service.

It is possible to create a "native debug" build that will connect to the EAS update service and allow debugging of native code. See the [last section of this document](/eas-update/getting-started/#testing-updates-with-a-debug-build-of-your-app) for the changes needed.)

</Step>

<Step label="6">

Make the modifications below to **App.js** so that the app uses the `Updates` API to show if it has downloaded and run an update.

{/* prettier-ignore */}
``` jsx App.js
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';
/* @info New */ import * as Updates from 'expo-updates'; /* @end */

export default function App() {
  /* @info New */ const runTypeMessage = Updates.isEmbeddedLaunch /* @end */
  /* @info New */   ? 'This app is running from built-in code' /* @end */
  /* @info New */   : 'This app is running an update'; /* @end */
  return (
    <View style={styles.container}>
      <Text>Open up App.js to start working on your app!</Text>
      /* @info New */ <Text>{runTypeMessage}</Text> /* @end */
      <StatusBar style="auto" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```

Then build and run the app again:

<Terminal
  cmd={[
    '# iOS: Build and run the app on a local iOS Simulator.',
    '$ npx expo run:ios --configuration Release',
    '',
    '# Android: Build and run the app on a local Android Emulator',
    '$ npx expo run:android --variant release',
    '',
  ]}
  cmdCopy="npx expo run:ios --configuration Release && npx expo run:android --variant release"
/>

The app should appear as in the screenshot below.

<ImageSpotlight
  alt="App running for the first time"
  src="/static/images/eas-update/getting-started-before-update.png"
  style={{maxHeight: 600, width: 'auto'}}/>
</Step>

<Step label="7">

## Publish an update

Now we're ready to publish an update that will include our changes.

After optionally making additional changes to **App.js**, publish an update with the following command:

<Terminal cmd={['$ eas update', '']} cmdCopy="eas update" />

There will be a prompt for the branch to publish on; select the default branch "main".

There will be a second prompt for entering an update message; select the default "Initial commit", or type in a custom message.

Once the update is built and uploaded to EAS and the command completes, force close and reopen your app up to two times to download and view the update.

The app should now appear as in the screenshot below.

<ImageSpotlight
  alt="App running update after being restarted twice"
  src="/static/images/eas-update/getting-started-after-update.png"
  style={{ maxHeight: 600, width: 'auto' }}
/>

</Step>

## Testing updates with a debug build of your app

It is possible to [create a debug build that will load updates from EAS instead of loading from a React Native packager](/eas-update/debug-updates/#debugging-of-native-code-while-loading-the-app-through-expo-updates).

To do this for the above app, we need to modify step 4 above as follows:

<Terminal
  cmd={[
    '# Set the environment variable needed for native debug builds',
    '$ export EX_UPDATES_NATIVE_DEBUG=1',
    '',
    '# Run prebuild to install and configure the ios and android directories, and install Cocoapods for iOS.',
    '$ npx expo prebuild',
    '',
    '# iOS: Modify the application project so that the application JavaScript',
    '',
    '# is bundled into the app for both debug and release builds.',
    "$ sed -i '' 's/SKIP_BUNDLING/FORCE_BUNDLING/g;' ios/<project name>.xcodeproj/project.pbxproj",
    '',
    '# iOS: Build and run the app on a local iOS Simulator.',
    '$ npx expo run:ios --configuration Debug',
    '',
    '# Android: Build and run the app on a local Android Emulator',
    '$ npx expo run:android --variant debug',
    '',
  ]}
  cmdCopy={null}
/>

The resulting app will be fully debuggable with Xcode or Android Studio, but will work with the EAS update service the same way as a release build, and will not connect to a local packager.

## Next steps

Use EAS Build and Update together. Learn more: [Using EAS Build and Update together](/eas-update/build-and-update)
